#!/usr/bin/env ruby
require 'optparse'
require 'fileutils'
require "net/http"
require "uri"
require "json"
require 'colorize'

options = {}
namespace_id = 0

###################
#
# We will parse all possible options in the following block of code
#
###################

OptionParser.new do |opts|
  opts.banner = "Usage: gitify [options]"

  opts.on("-n", "--project_name=PROJECT_NAME", "Define the project name for your project. If this is empty, \"CrossCheck\" will be used.") do |project_name|
    options[:project_name] = project_name
  end
  
  opts.on("-d", "--domain=LOCALDOMAIN", "Define the local development domain for this project. If this is empty, PROJECTNAME.dev will be used.") do |domain|
    options[:domain] = domain
  end
    
  opts.on("-n", "--namespace=NAMESPACE", "Define the namespace of the repository. if this is empty, no namespace will be used.") do |namespace|
    options[:namespace] = namespace
  end

  #opts.on("-g", "--git=REPOSITORY", "Define the repository.git | Example: --git=test.git") do |git|
  #  options[:git] = git
  #end

  opts.on("-a", "--all", "Provision all branches. (Staging, Acc, Production, Master)") do |all|
        options[:all] = all
  end

  opts.on("-br", "--branche=BRANCHES", "Branches split by a ,") do |branches|
        options[:branches] = branches
  end

  opts.on("-p", "--projecttype=TYPE", "Type: drupal(didi) or general (capistano)") do |type|
      options[:type] = type
  end

  opts.on("-d", "--directory=DIRECTORY", "The place where gitify has to create your structure") do |dir|
      options[:dir] = dir
  end

  opts.on("-t", "--gitlab_token=TOKEN", "The private gitlab token") do |token|
    options[:token] = token
  end

  opts.on("-u", "--gitlab_domain=DOMAIN", "The url to your gitlab installation") do |url|
    options[:gitlab_url] = url
  end

  opts.on("-v", "--vagrant_url=VAGRANT_URL", "Define the URL for a vagrant repository.") do |vagrant_url|
    options[:vagrant_url] = vagrant_url
  end
end.parse!


###################
#
# The following small piece of code will check what branches the user chose.
#
# If it's -a then all standard branches will be created
# Otherwise it will create the one that have been chosen by the user.
#
###################
branch_arr = []

if options[:all]
  branch_arr = ["staging","acc","production"]
elsif options[:branches].length > 0
  branch_arr = options[:branches].split(',')
else
  puts "No branches defined. Will only provision master branch."
end

###################
#
# The following two requests will allow us to communicate with the gitlab server API
# The first will try to get the ID of the namespace that we specified in the parameters. If this ID cannot be found, we will abort gitify.
#
# The second request will create a repository (through the API of gitlab) based on the specified options.
#
###################

puts "Getting namespace ID..."
uri_groups = URI.parse("http://#{options[:gitlab_url]}/api/v3/groups?private_token=#{options[:token]}")
http_groups = Net::HTTP.new(uri_groups.host, uri_groups.port)
request_groups = Net::HTTP::Get.new(uri_groups.request_uri)

response_groups = http_groups.request(request_groups)

groups_json = JSON.parse(response_groups.body)
groups_json.each do |item|
  if item["name"] == options[:namespace]
    namespace_id = item["id"]
  end
end

if namespace_id == 0
  puts "Namespace has not been found on the git-server!".red
  abort()
end

puts "Creating repository..."
uri_repo = URI.parse("http://#{options[:gitlab_url]}/api/v3/projects?private_token=#{options[:token]}")
http_repo = Net::HTTP.new(uri_repo.host, uri_repo.port)
request_repo = Net::HTTP::Post.new(uri_repo.request_uri)
request_repo.set_form_data({
                        #"name"  =>  options[:git][0..-5],
                        "name"  =>  options[:project_name],
                        "namespace_id"  =>  namespace_id
                      })
response_repo = http_repo.request(request_repo)

namespace = options.has_key?(:namespace) ? options[:namespace] + "/" : ""

###################
#
# The following piece of code will do some rudimentary checks on the specified directory format
# It will edit the parameter if it's malformed.
#
###################
if options.has_key?(:type) && options.has_key?(:dir)
    direc = options[:dir]
    typec = options[:type]
elsif options.has_key?(:dir)
    direc = options[:dir]
    typec = ""
else
  puts "You have to define at least your directory!"
  exit
end

if typec.length > 1
    
    full_direc_typec = "--directory=#{direc} --type=#{typec}"
else
    full_direc_typec = "--directory=#{direc}"
end

###################
#
# This last piece of code will clone the repository
# - Create the master branch and put all files in it
# - Create all other branches and push them to the repository server.
#
###################

#output_git_clone = `git clone git@#{options[:gitlab_url]}:#{namespace}#{options[:git]}`
output_git_clone = `git clone git@#{options[:gitlab_url]}:#{namespace}#{options[:project_name]}`
if $?.success?
  output_projectify_master = `cd #{options[:project_name]} && projectify #{full_direc_typec} --project_name=#{options[:project_name]} --host_name=#{options[:domain]} -v #{options[:vagrant_url]}`
  puts output_projectify_master
  output_commit_master = `cd #{options[:project_name]} && git add . && git commit -am "Initial structure" && git push origin master`
  branch_arr.each do |branch|
    output_branch = `cd #{options[:project_name]} && git branch #{branch} && git checkout #{branch} && git push origin #{branch}`
  end
  FileUtils.rm_rf(options[:project_name])
else
  puts "Something went horribly wrong."
end
